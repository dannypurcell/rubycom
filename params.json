{"name":"Rubycom","tagline":"Makes building a command line tool as easy as writing a function library","body":"Rubycom\r\n---------------\r\n\r\n&copy; Danny Purcell 2013 | MIT license\r\n\r\nMakes creating command line tools as easy as writing a function library.\r\n\r\nWhen a module is run from the terminal and includes Rubycom, Rubycom will parse ARGV for a command name,\r\nmatch the command name to a public singleton method (self.method_name()) in the including module, and run the method\r\nwith the given arguments.\r\n\r\nFeatures\r\n---------------\r\n\r\nAllows the user to write a properly documented module/class as a function library and convert it to a command line tool\r\nby simply including Rubycom at the bottom.\r\n\r\n* Provides a Command Line Interface for any function library simply by stating `include Rubycom` at the bottom.\r\n* Public singleton methods are made accessible from the terminal. Usage documentation is pulled from method comments.\r\n* Method parameters become required CLI arguments. Optional (defaulted) parameters become CLI options.\r\n* Command consoles can be built up by including other modules before including Rubycom.\r\n* Included modules become commands, their public singleton methods become sub-commands.\r\n\r\n\r\nRaison d'etre\r\n---------------\r\n\r\n* From scratch command line scripts often include redundant ARGV parsing code, little to no testing, slim documentation.\r\n* OptionParser and the like help script authors define options for a script.\r\n  They provide structure to the redundant code and slightly easier argument parsing.\r\n* Thor and the like provide a framework the script author will extend to create command line tools.\r\n  Prescriptive approach creates consistency but requires the script author to learn the framework and conform.\r\n\r\nWhile these are things are nice, we are still writing redundant code and\r\ntightly coupling the functional code to the interface which presents it.\r\n\r\nAt it's core a terminal command is a function. Rather than requiring the authors to make concessions for the presentation and\r\ntightly couple the functional code to the interface, it would be nice if the author could simply write a function library\r\nand attach the interface to it.\r\n\r\nHow it works\r\n---------------\r\nRubycom attaches the CLI to the functional code. The author is free to write the functional code as any other.\r\nIf a set of functions needs to be accessible from the terminal, just `include Rubycom` at the bottom and run the ruby file.\r\n\r\n* Public singleton methods are made accessible from the terminal.\r\n* ARGV is parsed for a method to run and arguments.\r\n* Usage documentation is pulled from method comments.\r\n* Method parameters become required CLI arguments.\r\n* Optional (defaulted) parameters become CLI options.\r\n\r\nThe result is a function library which can be consumed easily from other classes/modules and which is accessible from the command line.\r\n\r\nComing Soon\r\n---------------\r\n* Run Pre-configured sets of commands from a yaml file by calling <script.rb> job <job_yaml>\r\n* Job help/usage output will include descriptions from command for each step\r\n* Build a job yaml by running each command in sequence with a special option --job_add <path_to_yaml>\r\n* Edit job files from the command line using special options.\r\n    * --job_update <path_to_yaml>\r\n    * --job_rm <path_to_yaml>\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}