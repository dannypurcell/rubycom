{"name":"Rubycom","tagline":"Makes building a command line tool as easy as writing a function library","body":"Rubycom\r\n---------------\r\n\r\n&copy; Danny Purcell 2013 | MIT license\r\n\r\nMakes creating command line tools as easy as writing a function library.\r\n\r\nWhen a module is run from the terminal and includes Rubycom, Rubycom will parse ARGV for a command name,\r\nmatch the command name to a public singleton method (self.method_name()) in the including module, and run the method\r\nwith the given arguments.\r\n\r\nFeatures\r\n---------------\r\n\r\nAllows the user to write a properly documented module/class as a function library and convert it to a command line tool\r\nby simply including Rubycom at the bottom.\r\n\r\n* Provides a Command Line Interface for any function library simply by stating `include Rubycom` at the bottom.\r\n* Public singleton methods are made accessible from the terminal. Usage documentation is pulled from method comments.\r\n* Method parameters become required CLI arguments. Optional (defaulted) parameters become CLI options.\r\n* Command consoles can be built up by including other modules before including Rubycom.\r\n* Included modules become commands, their public singleton methods become sub-commands.\r\n\r\nUsage\r\n---------------\r\n\r\nWrite your module of methods, document them as you normally would. `include Rubycom` at the bottom.\r\nOptionally `#!/usr/bin/env ruby` at the top.\r\n\r\nNow any singleton methods `def self.method_name` will be available to call from the terminal.\r\n\r\nCalling `ruby ./path/to/module.rb <command_name>` will automatically discover and run your `<command_name>` singleton method.\r\nIf no method is found by the given name, a usage print out will be given including a summary of each command available\r\nand it's description from the corresponding method's comments.\r\n\r\nCalling a valid command with incorrect arguments will produce a usage print out for the matched method.\r\nRubycom will include as much documentation on the command line as you provide in your method comments. Currently Rubycom\r\nonly handles @param and @return annotation style comments for discovering the method comments regarding params and return values.\r\nAll other commentary will be included as part of the command description. In the absence of @param or @return comments,\r\nRubycom will also leave off the corresponding Param: and Return: markers in the usage output.\r\n\r\n#####Special commands\r\n\r\n|                 Command                            | Description                                                             | Options                                                             |\r\n| :------------------------------------------------- | :---------------------------------------------------------------------- | :------------------------------------------------------------------ |\r\n| `ruby ./path/to/module.rb help [command_name]`     | Will print out usage for the module or optionally the specified command.|                                                                     |\r\n| `ruby ./path/to/module.rb job </path/to/job.yaml>` | Runs the specified job file. See: \"Jobs\" below.                         | `--test` Prints the steps and context without running the commands. |\r\n\r\n\r\n###Arguments\r\n\r\n* Arguments are automatically parsed from the command line using Ruby's core Yaml module.\r\n* Arguments will be passed to your method in order of their appearance on the command line.\r\n* If you specify a default value for a parameter in your method, then Rubycom will look for a named argument matching\r\n    the parameter's name.\r\n* Users may call out option parameters in any order using `--<param_name>=<value>` or `--<param_name> <value>`\r\n    * Currently Rubycom does not yet support sort names for optional parameters so specifying `-<param_name>`\r\n        is equivalent to `--<param_name>`\r\n* In the absence of a named option, any optional parameters still unfilled will be filled by unnamed arguments in\r\n    order of appearance.\r\n* Optional parameters which do not get overridden either by a named option specification or an available unnamed\r\n    argument will be filled by their default as usual.\r\n* If a rest parameter `*param_name` is defined in the method being called, any remaining arguments will be passed to the\r\n    rest parameter after the required and optional parameters are filled.\r\n\r\n###Jobs\r\n\r\nJobs are a higher order orchestration mechanism for command line utilities. Rubycom provides a simple job runner to every\r\ncommand line utility. by calling `ruby ./path/to/module.rb job </path/to/job.yaml>` with a valid job yaml. Rubycom will\r\nrun your job.\r\n\r\n* A valid job file is a Yaml file which specifies a `steps` node and any number of valid numbered child nodes\r\n* Optionally, an `env` node may specified.\r\n    * If specified, `env` should include child nodes which are `key: value` pairs Ex: `working_dir: ./test/rubycom`\r\n    * If an `env` is specified, values may be inserted into commands in the `steps` node as such: `env['key']`\r\n         * Ex: `ruby env[working_dir]/util_test_composite.rb test_composite_command env[test_msg]`\r\n* A valid `steps` child node is a numbered node `1:` with a `cmd:` child node and optionally several context `desc:`\r\n    child nodes.\r\n* A `cmd:` node should specify the command string to run. Ex: `cmd: ls ./test_folder`\r\n* A context node should specify some text to be placed with the node's key in a formatted\r\n    logging context Ex: `desc: Run test_composite_command`\r\n\r\nBelow is an example job file which demonstrates the format Rubycom supports.\r\n\r\n    ---\r\n    env:\r\n      test_msg: Hello World\r\n      test_arg: 123\r\n      working_dir: ./test/rubycom\r\n    steps:\r\n      1:\r\n        desc: Run test_composite_command with environment variable\r\n        cmd: ruby env[working_dir]/util_test_composite.rb test_composite_command env[test_msg]\r\n      2:\r\n        Var: Run UtilTestModule/test_command_options_arr with environment variable\r\n        cmd: ruby env[working_dir]/util_test_composite.rb UtilTestModule test_command_options_arr '[\"Hello World\", world2]'\r\n      3:\r\n        Context: Run test_command_with_args with environment variable\r\n        cmd: ruby env[working_dir]/util_test_module.rb test_command_with_args env[test_msg] env[test_arg]\r\n      4:\r\n        Cmd: Run ls for arbitrary command support\r\n        cmd: ls\r\n      5:\r\n        Arbitrary_Context: Run ls with environment variable\r\n        cmd: ls env[working_dir]\r\n\r\n\r\nRaison d'etre\r\n---------------\r\n\r\n* From scratch command line scripts often include redundant ARGV parsing code, little to no testing, slim documentation.\r\n* OptionParser and the like help script authors define options for a script.\r\n  They provide structure to the redundant code and slightly easier argument parsing.\r\n* Thor and the like provide a framework the script author will extend to create command line tools.\r\n  Prescriptive approach creates consistency but requires the script author to learn the framework and conform.\r\n\r\nWhile these are things are nice, we are still writing redundant code and\r\ntightly coupling the functional code to the interface which presents it.\r\n\r\nAt it's core a terminal command is a function. Rather than requiring the authors to make concessions for the presentation and\r\ntightly couple the functional code to the interface, it would be nice if the author could simply write a function library\r\nand attach the interface to it.\r\n\r\nHow it works\r\n---------------\r\nRubycom attaches the CLI to the functional code. The author is free to write the functional code as any other.\r\nIf a set of functions needs to be accessible from the terminal, just `include Rubycom` at the bottom and run the ruby file.\r\n\r\n* Public singleton methods are made accessible from the terminal.\r\n* ARGV is parsed for a method to run and arguments.\r\n* Usage documentation is pulled from method comments.\r\n* Method parameters become required CLI arguments.\r\n* Optional (defaulted) parameters become CLI options.\r\n\r\nThe result is a function library which can be consumed easily from other classes/modules and which is accessible from the command line.\r\n\r\nComing Soon\r\n---------------\r\n* Build a job yaml by running each command in sequence with a special option --job_add <path_to_yaml>[:step_number]\r\n* Edit job files from the command line using special options.\r\n    * --job_update <path_to_yaml>[:step_number]\r\n    * --job_remove <path_to_yaml>[:step_number]","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}